替换dnd-kit-sortable-tree为自定义组件树形结构拖拽完整方案（含展开收起功能）

一、方案核心目标

适配“60+复杂节点（含antd Row/Col/Input）+跨分组拖拽+展开收起”需求，兼顾交互流畅性、数据一致性与可维护性，降低前后端协作成本。

二、数据层设计

1. 数据来源与存储

- 后端交互：后端返回扁平结构数据，需包含字段： id （节点唯一标识）、 parentId （父节点ID）、 groupid （分组/树标识）、 name/code （节点业务字段）。

- 前端存储：用Zustand管理2类核心状态：

-  flatData ：存储后端原始扁平数据，避免二次加工导致数据冗余；

-  expandedKeys ：记录节点展开状态，格式为 { "group1-node1": true, "group2-node3": false } （ groupid+nodeid 确保跨树状态不混淆）。

2. 数据处理逻辑

- 分组拆分：组件内基于 groupid 将 flatData 拆分为多棵树（如 group1 对应树1， group2 对应树2），无需存储分组结果，确保数据与状态源一致；

- 树形转换：通过 useTreeData 钩子，按 parentId 将分组后的扁平数据转为嵌套树形结构，用 useMemo 缓存结果，避免重复计算；

- 局部更新：仅修改拖拽节点的 groupid / parentId （调用Zustand的 updateDragNode  action）、仅切换目标节点的展开状态（调用 toggleExpanded  action），不触发全量数据重渲染。

三、核心交互实现

1. 跨分组拖拽

- 拖拽上下文管理：用 dnd-kit 的 DndContext 统一管理多树拖拽， SortableContext 绑定单树节点，通过 closestCorners 实现精准碰撞检测；

- 可视化反馈：

- 拖拽指示器（Indicator）：根据碰撞位置显示“↑上方插入”“↓下方插入”“→作为子节点”，用固定定位跟随鼠标；

- 幽灵占位（GhostPlace）：生成与原节点同尺寸的半透明占位框，插入目标位置，直观展示投放结果；

- 非法拦截：拖拽结束前校验“根节点是否拖入子节点”“是否拖入只读树”，拦截时用 antd Message 提示，不触发数据更新。

2. 展开收起功能

- 基础控制：父节点旁添加“+/-”或箭头图标，点击触发 toggleExpanded  action，切换 expandedKeys 中对应节点的状态；

- 智能联动：拖拽节点靠近“收起的父节点”时，自动调用 toggleExpanded 展开该节点，无需用户手动操作；

- 初始与层级配置：支持配置初始状态（如“仅首层展开”“全部展开”），可设置最大展开层级（如5层），超过层级的子节点默认收起，避免界面混乱。

四、性能与体验优化

1. 渲染性能优化

- 轻量占位：拖拽中节点切换为“仅显示名称”的1层DOM，移除 Row/Col/Input 等复杂组件，减少重绘压力；

- 按需渲染：用 React.memo 包裹 TreeNode 组件，仅当节点自身数据或展开状态变化时重渲染； Indicator 和 GhostPlace 仅在拖拽时创建，避免冗余DOM。

2. 交互体验优化

- 空状态提示：分组下无节点时，显示“暂无节点，可从其他分组拖拽”提示，避免界面空白；

- 响应式适配：小屏幕下多棵树改为上下排列，展开收起图标放大适配触控操作，拖拽指示器限制在视口内，防止超出屏幕；

- 编辑兼容：节点编辑（如Input修改）不联动改变展开状态，编辑时仅更新当前节点业务字段，不影响其他交互。

五、边界与数据安全

1. 数据一致性保障

- 唯一性校验：确保 id 全局唯一， expandedKeys 用“groupid+nodeid”作为键，避免跨树状态混淆；

- 后端同步与回滚：前端更新拖拽节点/展开状态后，调用后端接口同步；若接口返回失败，用Zustand存储的原始数据回滚，防止“显示与实际数据不一致”。

2. 异常场景处理

- 节点ID冲突：初始化时校验 flatData 中是否存在重复 id ，发现冲突时提示后端修复；

- 层级循环检测：拖拽时校验“子节点是否拖入自身后代节点”，避免出现“节点A→节点B→节点A”的循环嵌套。